# SPDX-FileCopyrightText: 2024 H PHil Duby
#
# SPDX-License-Identifier: MIT

"""
Constants and shared code to use for adafruit_ntp unittesting.

Enhance consistency by grouping simple values used by more than one unittest (module).
Don't repeat constant value literals to avoid things getting out of sync.
"""

import os
import sys
import time

try:
    from typing import Tuple, Union, Any, List

    LogTupleT = Tuple[str, str, int, str, Tuple[Any]]
    ArgsTupleT = Union[Tuple[Any, ...], Any]  # pylint:disable=invalid-name
except ImportError:
    pass
try:
    # CPython
    import socket as SocketPool
    from unittest.case import _AssertRaisesContext as RaisesContext
except ImportError:
    # CircuitPython
    from socketpool import SocketPool  # type:ignore
    from unittest import AssertRaisesContext as RaisesContext
import adafruit_logging as logging

MOCK_LOGGER = "mocking_logger"
NS_PER_SEC = 1_000_000_000  # nanoseconds per second

NTP_PORT = 123
DEFAULT_NTP_ADDRESS = ("0.adafruit.pool.ntp.org", NTP_PORT)
NTP_PACKET_SIZE = 48
NTP_SERVER_IPV4_ADDRESS = "10.20.30.40"
NTP_ADDRESS_PORT = (NTP_SERVER_IPV4_ADDRESS, NTP_PORT)
ADDR_SOCK_KEY: Tuple[int, int, int] = (2, 2, 0)  # AF_INET, SOCK_DGRAM
IP_SOCKET: List[Tuple[int, int, int, str, Tuple[str, int]]] = [
    (2, 1, 0, "", NTP_ADDRESS_PORT)
]

# Messages and exceptions to mock

# For «pool».getaddressinfo(…)
GETADDR_DNS_MSG: Tuple[int, str] = (-2, "Name or service not known")
GAI_EXCEPTION = (
    SocketPool.gaierror
)  # will this vary depending on the connection source used?
GETADDR_DNS_EX = GAI_EXCEPTION(GETADDR_DNS_MSG)

# For NTP
BAD_EVENT_MASK_MSG: str = (
    "Invalid event type mask 0b%s. Only known events can receive notifications."
)

# Constants used and messages generated by mocking code.

# For mock_time.MockTime
MOCKED_TIME_DEFAULT_START_NS: int = 1_000_000_000
MOCKED_TIME_NEW_MSG: str = "mock time.__new__ called"
MOCKED_TIME_FIRST_NEW_MSG: str = "mock time.__new__ new instance"
MOCKED_TIME_MONOTONIC_NS_MSG: str = "mock time.monotonic_ns %s"
MOCKED_TIME_SLEEP_MSG: str = "mock time.sleep(%f)"
MOCKED_TIME_LOCALTIME_MSG: str = "mock time.localtime(%s)"
MOCKED_TIME_NOT_LOCALTIME_MSG: str = (
    "localtime from current system time not implemented for mock"
)
MOCKED_TIME_NOT_LOCALTIME_EX = NotImplementedError(MOCKED_TIME_NOT_LOCALTIME_MSG)

# For mock_pool.MockPool
MOCKED_POOL_NEW_MSG: str = "mock Pool.__new__ called"
MOCKED_POOL_INITIALIZED_MSG: str = "mock Pool instance initialized"
MOCKED_POOL_INIT_MSG: str = "mock Pool.__init__ called"
MOCKED_POOL_INIT_CLEARED_MSG: str = "mock Pool.__init__ queued attempts cleared"
MOCKED_POOL_GETADDR_MSG: str = "mock Pool.getaddrinfo %s:%s"
MOCKED_POOL_SOCKET_MSG: str = "mock Pool.socket called for %d:%d:%d"

# For mock_pool.MockSocket
MOCKED_SOCK_NEW_MSG: str = "mock Socket.__new__%r called"
MOCKED_SOCK_SUPER_MSG: str = "mock Socket.__new__%r super called"
MOCKED_SOCK_INITIALIZED_MSG: str = "mock Socket instance initialized for %r"
MOCKED_SOCK_INIT_MSG: str = "mock Socket.__init__%r called"
MOCKED_SOCK_ENTER_MSG: str = "mock Socket.__enter__ called for %r"
MOCKED_SOCK_EXIT_MSG: str = "mock Socket.__exit__ called for %r"
MOCKED_SOCK_SETTIMEOUT_MSG: str = "mock Socket.settimeout(%d) called for %r"
MOCKED_SOCK_SENDTO_MSG: str = "mock Socket.sendto(packet,%r) called for %r"
MOCKED_SOCK_RECV_INTO_MSG: str = "mock Socket.recv_into(packet) called for %r"
MOCKED_SOCK_CLOSE_MSG: str = "mock Socket.close called for %r"

MOCKED_NO_RESOURCE_MSG: str = "No response value available to mock %s"
MOCKED_CALLBACK_MSG: str = 'Mock notification callback "%s" for event %s and delay %d'


class ListHandler(logging.Handler):
    """Save log records to a list"""

    def __init__(self, *args, **kwargs):
        # super(ListHandler, self).__init__(*args, **kwargs)
        super().__init__(*args, **kwargs)
        self.log_records: List[logging.LogRecord] = []

    def emit(self, record: logging.LogRecord) -> None:
        """capture the log record"""
        self.log_records.append(record)

    def log_also_to_me(self, logger: logging.Logger) -> bool:
        """add the list handler instance to a Logger"""
        for existing_handler in logger._handlers:  # pylint:disable=protected-access
            if existing_handler == self:
                return False  # already there
        logger.addHandler(self)
        return True

    def log_only_to_me(self, logger: logging.Logger) -> None:
        """replace all handlers of a Logger with just me"""
        # pylint:disable=protected-access
        while logger._handlers:
            logger.removeHandler(logger._handlers[0])
        logger.addHandler(self)

    def to_tuple(self) -> Tuple[LogTupleT, ...]:  # type:ignore
        """
        log record data, without timestamp, as a tuple that can be directly compared
        for unittest verification.

        :return tuples containing name, levelname, levelno, msg, args
        :rtype Tuple[LotTupleT]: Tuple[Tuple[str, str, int, str, Tuple[Any]]]
        """
        if not self.log_records:
            return tuple()
        return tuple(_make_tuple(rec) for rec in self.log_records)


class ResourcesDepletedError(IndexError):
    """
    Exception for mocking code to use when provided resources are not sufficient for
    the current request.
    """


def setup_logger(name: str) -> logging.Logger:
    """
    Sets up and returns a logger with the specified name.

    This function checks the running environment and sets up the logging
    appropriately for CircuitPython or standard Python. For standard Python,
    it also configures a stream handler with a specific format.

    :param str name: The name of the logger. Typically MOCK_LOGGER.
    :return: A configured logging.Logger object for the specified name.
    """
    logger = logging.getLogger(name)
    # logger.setLevel(unittest_logging_level)
    if not logger._handlers:  # pylint:disable=protected-access
        # Only add 'project' handler when none exist yet
        handler = logging.StreamHandler()
        logger.addHandler(handler)

    return logger


def set_utc_timezone() -> None:
    """
    Set local time to UTC for CPython. CircuitPython uses UTC by default.
    """
    try:
        # Set the local timezone to UTC. Only needed when running unittests from CPython.
        os.environ["TZ"] = "UTC"
        time.tzset()  # Set the local timezone to UTC
    except AttributeError:
        pass  # setting environment variables is not available in CircuitPython


def make_log_rec(
    name: str, msg: str, level: int = 20, args: Union[Tuple[Any, ...], Any] = ()
) -> LogTupleT:  # type:ignore
    """
    Create expected log record for logger name, level and msg.

    This builds a tuple that can be directly compared to an entry returned by the
    ListHandler.to_tuple() method.

    :param str name: name of the logger
    :param str msg: message to log
    :param int level: logging level, default 20 (info)
    :param tuple args: arguments to pass to the log method, default ()
    :return: tuple, log record without timestamp
    """
    args_tuple = args if isinstance(args, tuple) else (args,)
    return (
        name,
        logging._level_for(level),  # pylint:disable=protected-access
        level,
        msg % args_tuple,
        args_tuple,
    )  # pylint:disable=protected-access


def make_mock_rec(
    msg: str, level: int, args: Union[Tuple[Any, ...], Any] = ()
) -> LogTupleT:  # type:ignore
    """
    Create expected log record for MOCK_LOGGER, level and msg.

    :param str msg: message to log
    :param int level: logging level
    :param tuple args: arguments to pass to the log method, default ()
    :return: tuple, log record
    """
    return make_log_rec(MOCK_LOGGER, msg, level, args)


def mock_info(msg: str, args: ArgsTupleT = ()) -> LogTupleT:  # type:ignore
    """Create expected mock log record for INFO level and msg."""
    return make_mock_rec(msg, logging.INFO, args)  # pylint:disable=no-member


def _make_tuple(rec: logging.LogRecord) -> LogTupleT:  # type:ignore
    """
    log record data, without timestamp, as a tuple that can be directly compared
    for unittest verification.

    :param logging.LogRecord rec: the log record to convert
    :return: tuple, the converted log record data
    """
    tmp_args = (
        rec.args if rec.args is None or isinstance(rec.args, tuple) else (rec.args,)
    )
    return str(rec.name), str(rec.levelname), int(rec.levelno), str(rec.msg), tmp_args


def get_context_exception(context: RaisesContext) -> Exception:
    """Get the exception from the context manager.

    Handle difference between unittest for CPython and CircuitPython.
    """
    # pylint:disable=no-member
    return (
        context.exception_value
        if hasattr(context, "exception_value")
        else context.exception
    )


def fmt_thousands(n: int) -> str:
    """Format number with thousands separators."""
    return f"{n:,}"


def mock_cleanup() -> None:
    """Clean up after mocking code."""
    testing_modules = [
        "tests.ntp_testing_support",
        "tests.simulate_ntp_packet",
        "tests.shared_for_testing",
        "adafruit_ntp",
        "tests.mocks.mock_pool",
        "time",
        "tests.mocks.mock_time",
        "tests.mocks",
    ]
    if sys.implementation.name == "circuitpython":
        # CPython unittest crashes if the module being run is deleted before it can be unloaded.
        testing_modules.extend(
            [
                "tests.test_eventtype",
                "tests.test_mock",
                "tests.test_ntp_instantiation",
                "tests.test_ntp_registration",
                "tests.test_ntp",
                "tests",
            ]
        )
    for module_name in testing_modules:
        if module_name in sys.modules:
            try:
                del sys.modules[module_name]
            except KeyError:
                pass
